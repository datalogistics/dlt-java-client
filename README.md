# [Data Logistics Toolkit][DLT] - Client [![Data Logistics Toolkit](http://dlt.incntre.iu.edu/webstart/html/DLTlogo.png)][DLT]

---
## Introduction
The following sections describe the Data Logistics Toolkit's JAVA client and its main components. This README is targeted towards future developers/programmers of the DLT project. I hope it gets you quick-started and answers most of the questions that come up during the course of the development. Please keep this artifact updated with the future developments on the project.  

---
## Components
1. Uploader/Downloader Client
  * .form files are generated using NetBeans IDE that allows visual WYSIWYG editing of UI components. It advisable to change the UI components' graphic properties using NetBeans only, and not alter the initComponents() method that is auto-generated by NetBeans from the .form files.
  * [UploadDownloadFrame](./src/edu/crest/dlt/ui/main/UploadDownloadFrame.java) - contains the main() method and is the launcher class for the DLT client
  * [CommandLineOptionParser](./src/edu/crest/dlt/ui/utils/CommandLineOptionParser.java) - parses the command line inputs to the client; currently accepts local .xnd (XML encoded exnode), .uef (JSON encoded exnode) files or UNIS URL's to exnodes
  * FilesPanel - displays the names of files available for transfer ([download](./src/edu/crest/dlt/ui/down/FilesPanel.java) / [upload](./src/edu/crest/dlt/ui/up/FilesPanel.java))
  * TransferSettingsPanel - allows the user to select the preferred settings for performing the transfer
     * [download](./src/edu/crest/dlt/ui/down/TransferSettingsPanel.java)
     * [upload](./src/edu/crest/dlt/ui/up/TransferSettingsPanel.java) - list of depots is requested from LBone server (may be replaced by some other discovery service in the future), based on the pre-configured locations and lbone server settings in [config.properties](./src/edu/crest/dlt/utils/config.properties "DLT client configuration file"), at UI load time; all depots known to the client are stored in a static List of depots with (attempted) connection pools and are displayed to the user to choose from for publishing their content
  * [TransferProgressPanel](./src/edu/crest/dlt/ui/utils/TransferProgressPanel.java) - shows runtime progress of the ongoing transfer (download/upload)

2. [Exnode](./src/edu/crest/dlt/exnode/Exnode.java)
   * the downloader obtains metadata from the XML or JSON serialized object and constructs an exnode for downloading contents of the file; the uploader creates an exnode with the specified filename and populates its metadata as the upload/publish progresses
   * is a metadata-container containing metadata related to the mappings of a file hosted on the DLT network
   * maintains a queue of transfer jobs
   * maintains a list of transfer threads/workers

3. [Allocation](./src/dlt-client/src/edu/crest/dlt/ibp/Allocation.java)
   * an allocation represents a chunk (offset, length in bytes) of a file's content hosted on a depot with one or more [capabilities](./src/dlt-client/src/edu/crest/dlt/ibp/Capability.java) (Read/Write/Manage)

4. [Mapping](./src/dlt-client/src/edu/crest/dlt/exnode/Mapping.java)
   * a mapping represents an allocation replicated on one (i.e. no replication) or more (typically 3) distinct depots. Replicas of the same mapping have the same offset and length but different depots
   * even one of the mappings corresponding to the same offset is accessible, that chunk can be downloaded

5. [Depot](./src/dlt-client/src/edu/crest/dlt/ibp/Depot.java)
   * a depot (i.e. an IBP depot) represents an IBP storage-retrieval service
   * maintains a static set of available depots currently known to the client
   * maintains a pool of connections to the IBP server - the connection/socket pool is initialized when the Depot object is created and is released when the object gets destroyed/finalized

6. File [Read](./src/dlt-client/src/edu/crest/dlt/bd/diskio/FileReadThread.java)/[Write](./src/dlt-client/src/edu/crest/dlt/bd/diskio/FileWriteThread.java) Threads
   * singleton thread for performing read/write from/to a file's content
   * A ReadJob, buffers data received from a depot, then the ReadThread submits the ReadJob to the FileWriteThread - an exnode read operation completes successfully only after all the received data has been written out to disk
   * A WriteThread requests data from disk by submitting a WriteJob to the FileReadThread - a WriteJob can be performed only after its data has been buffered (#ThanksForStatingTheObvious!!! #Chuckles)
   * If a read operation succeeds in fetching all the data pertaining to the file, it must not interrupt the fileWriteThread until it finishes writing all the data to disk (#Again #ThanksForStatingTheObvious!!! #SucceedSlowly)

7. Transfer ([Read](./src/dlt-client/src/edu/crest/dlt/transfer/ReadThread.java)/[Write](./src/dlt-client/src/edu/crest/dlt/transfer/WriteThread.java)) Threads
   * A ReadThread understands the states of a ReadJob and makes necessary decisions based on a ReadJob's current state
   * A WriteThread understands the states of a WriteJob and makes necessary decisions based on a WriteJob's current state
   * If any transfer-thread identifies that a transfer-job has failed more than its permissible number of retries, it must notify the exnode, which in turn must interrupt (immediately) all other transfer-threads. (#FailEarlyPolicy)

8. Transfer ([Read](./src/dlt-client/src/edu/crest/dlt/transfer/ReadJob.java)/[Write](./src/dlt-client/src/edu/crest/dlt/transfer/WriteJob.java)) Jobs
   * ReadJobs targeting the same mappings hold references to the same list of mappings that is used as a MaxHeap (max meaning the best mapping for performing the next ReadJob)(this part is experimental and may not be too useful - I assume it still performs better than scanning through the entire (typically size=3) list of mappings at little to no additional overhead)
   * A WriteJob with buffered data keeps the data buffered until it either succeeds in making the desired number of copies/replicas (allocations) or causes the exnode's write operation to fail

---
## Development Tools
1. [Eclipse IDE](https://www.eclipse.org/downloads/ "Download Eclipse") - Backend.
   * Eclipse was used for the convenience of writing the business logic of the DLT client
2. [NetBeans IDE](https://netbeans.org/downloads/ "Download NetBeans") - Frontend/UI
   * The frontend/UI was developed using NetBeans for its simplicity and short learning curve. Display related properties of UI components must be edited using NetBeans (so refrain from making changes to the parts of UI code marked as auto-generated).

---
## Coding standards and naming conventions
* Counting on the fact that existence or non-existence of a parameter is a sufficient indication of the intent of a method-call, I have diverged a bit from the typical JAVA naming conventions, eg.

```java
/* same name for getter-setter, or
 * for serializer-deserializer 
 * but different parameters */

/**********************************************************/
public void setDepot(Depot depot) // Depot setter
// has been changed to
public void depot()

// while
public Depot getDepot() // Depot getter
// has been changed to
public Depot depot() // NOTE: return type is different 
                     // from that of the setter

/**********************************************************/
public String fromXML(Element xml) // XML deserializer
// has been changed to ...
public String xml(Element xml)

// while
public void toXML() // XML serializer
// has been changed to ...
public void xml() // NOTE: return type is different 
                  // from that of the deserializer
/**********************************************************/
```

* Also I have diverged a bit from the typical encapsulation in favor of ease of access to variables within a class that provide both getter and setter, eg.

```java
/* public variable instead of private variable with getter-setter */

/**********************************************************/
private Depot depot;
public void setDepot(Depot depot) { ... }
public Depot getDepot() { ... }

// the above scheme has been replaced by
public Depot depot;

/**********************************************************/
// thus, a line of code such as ...
{ 
  ...
  depot = exnode.getMapping(...).getAllocation().getDepot();
  ...
}
// gets replaced by
{
  ...
  depot = exnode.mappings(...).allocation.depot;
  ...
}
/**********************************************************/
```

* Most `toString()` methods have been overridden to return a print-ready string instead of a serialized object reference.
* Active entities have a `public enum` `state` that for ease of communication between its handler/master/caller. This follows the simple philosophy that the worker does not ask its master/handler to do something but only updates its own state and lets its handler decide the future course of events. The only place where this has to be diverged is when a transfer-thread identifies failure to proceed with a transfer-job in which case it must cry-out to its handler i.e. the exnode to terminate the transfer operation. eg below.
* Active entities have a `public String status()` method that return the verbatim description of their current `state`. eg.

```java
public class ReadJob extends ConcurrentJob
{
  ...
  public enum state_readjob {
    nascent, ready, reading_data, read_data_buffered, done, failed,
  }
  public state_readjob state;
  
  public String status()
  {
    switch (state) {
      case nascent:
      ...
      case failed:
      default:
        return this + " [UNKNOWN-STATE]";
    }
  }
  ...
}
```

---
## Configuring the Client
Most of the client initialization and runtime configurations and behaviors can be found and changed in the [config.properties](./src/edu/crest/dlt/utils/config.properties "DLT client configuration file") file.

---
## Downloader
###

---
## Uploader
###

---
## Deployment
1. Prerequisite(s)

 * [Java keystore](https://www.sslshopper.com/article-most-common-java-keytool-keystore-commands.html)
 * Keys with keystore alias
 ```
 $ keytool -genkey -keystore bddltKeys -alias bddlt_keystore
 ```
 
2. Creating the `.jar` file
 * Clean-Build `dlt-client`
 * Navigate to `bddlt/src/dlt-client/bin/`
 * Copy `MANIFEST.MF` from `res/` to `bin/`
 ```
 $ cp ../resources/MANIFEST.MF
 ```
 * Create the project's executable `.jar` file
 ```
 $ jar cvfm dlt-client.jar MANIFEST.MF edu/
 ```
 * Sign the `dlt-client.jar` with the prepared keys.
 ```
 $ jarsigner dlt-client.jar 
or (preferably)
$ jarsigner -keystore bddltKeys dlt-client.jar bddlt_keystore
 ```

3. Deploying the .jar 
* Copy `dlt-client.jar` to [Development/Testing UNIS server][DLT-dev] 
```
dlt.incntre.iu.edu:/var/www/webstart/lib/ (requires sudo access)
```

4. Test the deployment by visiting the [web interface][DLT-web]; fill your shopping cart; click the download button to obtain the .jnlp; and execute it

[DLT]: http://www.data-logistics.org/ "Data Logistics Toolkit Homepage"
[DLT-dev]: http://dev.incntre.iu.edu:8888/ "DLT development/testing server"
[DLT-web]: http://dlt.incntre.iu.edu:42424/ "DLT web interface"